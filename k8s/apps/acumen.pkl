/// Kubernetes resources for the Acumen application
/// Generates Deployment, StatefulSet, Service, and PodDisruptionBudget manifests

module acumen

import "@k8s/K8sResource.pkl"
import "@k8s/api/apps/v1/Deployment.pkl"
import "@k8s/api/apps/v1/StatefulSet.pkl"
import "@k8s/api/core/v1/Service.pkl"
import "@k8s/api/policy/v1/PodDisruptionBudget.pkl"

local appName = "acumen"
local k8sNamespace = read?("env:K8S_NAMESPACE") ?? "bryzek-production"
local registry = "registry.digitalocean.com/bryzek"
local version = read?("env:VERSION") ?? "latest"
local appPort = 9200
local memoryDefault = "750Mi"
local memoryJobServer = "1500Mi"
local memoryLimit = "1Gi"
local memoryLimitJobServer = "2Gi"
local cpuLimit = "1000m"
local cpuLimitJobServer = "2000m"

// ImagePullPolicy: Always for latest, IfNotPresent otherwise
local pullPolicy = if (version == "latest") "Always" else "IfNotPresent"

local commonLabels: Mapping<String, String> = new {
  ["app"] = appName
  ["app.kubernetes.io/name"] = appName
  ["app.kubernetes.io/version"] = version
}

local webLabels: Mapping<String, String> = new {
  ["app"] = appName
  ["app.kubernetes.io/name"] = appName
  ["app.kubernetes.io/version"] = version
  ["tier"] = "web"
}

local jobLabels: Mapping<String, String> = new {
  ["app"] = appName
  ["app.kubernetes.io/name"] = appName
  ["app.kubernetes.io/version"] = version
  ["tier"] = "job"
}

resources: Listing<K8sResource> = new {
  // Web Deployment - serves HTTP traffic
  new Deployment {
    metadata {
      name = "\(appName)-web"
      namespace = k8sNamespace
      labels = commonLabels
    }
    spec {
      replicas = 2
      selector {
        matchLabels = new {
          ["app"] = appName
          ["tier"] = "web"
        }
      }
      strategy {
        type = "RollingUpdate"
        rollingUpdate {
          maxUnavailable = 0
          maxSurge = 1
        }
      }
      template {
        metadata {
          labels = webLabels
        }
        spec {
          containers = new {
            new {
              name = appName
              image = "\(registry)/\(appName):\(version)"
              imagePullPolicy = pullPolicy
              ports = new {
                new {
                  containerPort = appPort
                  protocol = "TCP"
                }
              }
              readinessProbe {
                httpGet {
                  path = "/_internal_/healthcheck"
                  port = appPort
                }
                initialDelaySeconds = 10
                periodSeconds = 5
                failureThreshold = 3
                timeoutSeconds = 5
              }
              livenessProbe {
                httpGet {
                  path = "/_internal_/healthcheck"
                  port = appPort
                }
                initialDelaySeconds = 30
                periodSeconds = 10
                failureThreshold = 5
                timeoutSeconds = 5
              }
              resources {
                requests {
                  ["memory"] = memoryDefault
                  ["cpu"] = "100m"
                }
                limits {
                  ["memory"] = memoryLimit
                  ["cpu"] = cpuLimit
                }
              }
              envFrom = new {
                new {
                  secretRef {
                    name = "\(appName)-secrets"
                  }
                }
                new {
                  configMapRef {
                    name = "\(appName)-config"
                  }
                }
              }
              securityContext {
                allowPrivilegeEscalation = false
                runAsNonRoot = true
                runAsUser = 1000
              }
            }
          }
        }
      }
    }
  }

  // Job Server StatefulSet - handles async job processing
  new StatefulSet {
    metadata {
      name = "\(appName)-job"
      namespace = k8sNamespace
      labels = jobLabels
    }
    spec {
      serviceName = "\(appName)-job"
      replicas = 1
      selector {
        matchLabels = new {
          ["app"] = appName
          ["tier"] = "job"
        }
      }
      template {
        metadata {
          labels = jobLabels
        }
        spec {
          containers = new {
            new {
              name = "\(appName)-job"
              image = "\(registry)/\(appName):\(version)"
              imagePullPolicy = pullPolicy
              env = new {
                new {
                  name = "DEPLOYMENT_JOB_SERVER"
                  value = "true"
                }
              }
              ports = new {
                new {
                  containerPort = appPort
                  protocol = "TCP"
                }
              }
              readinessProbe {
                httpGet {
                  path = "/_internal_/healthcheck"
                  port = appPort
                }
                initialDelaySeconds = 15
                periodSeconds = 10
                failureThreshold = 3
                timeoutSeconds = 5
              }
              livenessProbe {
                httpGet {
                  path = "/_internal_/healthcheck"
                  port = appPort
                }
                initialDelaySeconds = 45
                periodSeconds = 15
                failureThreshold = 5
                timeoutSeconds = 5
              }
              resources {
                requests {
                  ["memory"] = memoryJobServer
                  ["cpu"] = "100m"
                }
                limits {
                  ["memory"] = memoryLimitJobServer
                  ["cpu"] = cpuLimitJobServer
                }
              }
              envFrom = new {
                new {
                  secretRef {
                    name = "\(appName)-secrets"
                  }
                }
                new {
                  configMapRef {
                    name = "\(appName)-config"
                  }
                }
              }
              securityContext {
                allowPrivilegeEscalation = false
                runAsNonRoot = true
                runAsUser = 1000
              }
            }
          }
        }
      }
    }
  }

  // Web Service - exposes web deployment to ingress/load balancer
  new Service {
    metadata {
      name = "\(appName)-web"
      namespace = k8sNamespace
      labels = commonLabels
    }
    spec {
      selector = new {
        ["app"] = appName
        ["tier"] = "web"
      }
      ports = new {
        new {
          name = "http"
          port = 80
          targetPort = appPort
          protocol = "TCP"
        }
      }
      type = "ClusterIP"
    }
  }

  // Job Service - headless service for StatefulSet
  new Service {
    metadata {
      name = "\(appName)-job"
      namespace = k8sNamespace
      labels = jobLabels
    }
    spec {
      selector = new {
        ["app"] = appName
        ["tier"] = "job"
      }
      ports = new {
        new {
          name = "http"
          port = appPort
          targetPort = appPort
          protocol = "TCP"
        }
      }
      clusterIP = "None"
    }
  }

  // Pod Disruption Budget - ensures high availability during node maintenance
  new PodDisruptionBudget {
    metadata {
      name = "\(appName)-pdb"
      namespace = k8sNamespace
      labels = commonLabels
    }
    spec {
      minAvailable = 1
      selector {
        matchLabels = new {
          ["app"] = appName
          ["tier"] = "web"
        }
      }
    }
  }
}

output {
  renderer = new YamlRenderer {
    isStream = true
  }
  value = resources
}
