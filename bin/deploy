#!/usr/bin/env ruby

load File.join(File.dirname(__FILE__), '../lib/common.rb')
load File.join(File.dirname(__FILE__), '../lib/localhost/digital_ocean.rb') # only load here as pulls in droplet_kit

SKIP_UPLOAD = false
if SKIP_UPLOAD
    puts Util.warning("Skipping network operations / upload")
end

args = Args.parse(ARGV, ["app", "file"])
config = Config.load(args.app)
scala_config = config.scala
if scala_config.nil?
    Util.exit_with_error("App #{args.app} does not have a scala config")
end

env = scala_config.send(args.env)
file = args.file
vars = EnvironmentVariables.load(args.app, args.env)
start = Time.now

TMP_DIR = "/tmp/devops"
FileUtils.mkdir_p(TMP_DIR)

RUN_SCRIPT_NAME = "#{args.app}-#{config.scala.artifact_name}-run.sh"
RUN_SCRIPT = File.join(TMP_DIR, RUN_SCRIPT_NAME)

do_client = DigitalOcean::Client.new(args.app)

if !file.match (/\.tar\.gz$/)
    Util.exit_with_error("Release file must end with .tar.gz")
end
if !File.exist?(file)
    Util.exit_with_error("File #{file} does not exist")
end

def read_first_n_lines(file, n=20)
    IO.read(file).split.reverse.take(n).reverse.join("\n")
end

class DeploymentNode
    attr_reader :node, :status, :index
    def initialize(config, node, index, devops_token)
        @config = config
        @node = node
        @index = index.to_i
        @status = Healthcheck::UNKNOWN
        @devops_token = devops_token
    end

    def healthy?
        @status.healthy?
    end

    def job_server?
        @status.job_server?
    end

    def update_status
        output = execute("curl -s http://localhost:#{@config.port}/_internal_/healthcheck")
        @status = Healthcheck.from_json(output)
        nil
    end

    def localhost?
        @node.uri == "localhost"
    end

    def download_logfile
        download_file("#{@config.name}.log")
    end

    def execute(cmd)
        if localhost?
            `#{cmd}`.strip
        else
            tmp = "/tmp/deployment_node.%s.tmp" % @node.uri
            cmd = "ssh root@#{@node.uri} 'rm -f #{tmp}; #{cmd} > #{tmp}'"
            # puts "Executing command: #{cmd}"
            `#{cmd}`
            begin
                file = download_file(tmp)
                IO.read(file).strip
            ensure
                File.delete(tmp) if File.exist?(tmp)
            end
        end
    end

    def download_file(file)
        if localhost?
            file
        else
            tmp = "/tmp/#{File.basename(file)}"
            Util.run("scp -q root@#{@node.uri}:#{file} #{tmp}", :quiet => true)
            tmp
        end
    end

    def upload_file(file)
        if localhost?
            # No op
        else
            puts "uploading #{file} to #{node.uri}"
            Util.run("scp -q #{file} root@#{@node.uri}:~/", :quiet => true)
        end
    end

    def start_drain
        # Use escaped double quotes to avoid issues with SSH single-quote wrapping
        result = execute("curl -s -w \"\\n%{http_code}\" -X POST -H \"X-Devops-Token: #{@devops_token}\" http://localhost:#{@config.port}/_internal_/drain")
        lines = result.split("\n")
        http_code = lines.last.to_i
        body = lines[0..-2].join("\n")

        case http_code
        when 200
            puts " - Drain started successfully"
        when 401
            puts Util.warning(" - Drain endpoint returned 401 Unauthorized")
        when 0
            puts Util.warning(" - Failed to connect to drain endpoint")
        else
            puts Util.warning(" - Drain endpoint returned HTTP #{http_code}: #{body}")
        end
        result
    end
end

def wait_until_healthy_in_lb(do_client, dn, max_wait=30)
    max_wait.times do |i|
        dots = i % 3 + 1
        dot_display = "." * dots + " " * (3 - dots)
        print "\r - Waiting for LB to mark node healthy #{dot_display}"
        $stdout.flush
        if do_client.droplet_healthy_in_lb?(dn.node.uri)
            print "\r" + " " * 80 + "\r"
            $stdout.flush
            puts " - LB marked node healthy after #{i + 1}s"
            return true
        end
        sleep 1
    end
    print "\r" + " " * 80 + "\r"
    $stdout.flush
    puts Util.warning(" - LB did not mark node healthy within #{max_wait}s, proceeding anyway")
    false
end

def wait_until_unhealthy(dn, max_wait=30)
    max_wait.times do |i|
        dots = i % 3 + 1
        dot_display = "." * dots + " " * (3 - dots)
        print "\r - Waiting for health check to fail #{dot_display}"
        $stdout.flush
        dn.update_status
        if !dn.healthy?
            print "\r" + " " * 80 + "\r"
            $stdout.flush
            puts " - Health check failed after #{i + 1}s (node is draining)"
            return true
        end
        sleep 1
    end
    print "\r" + " " * 80 + "\r"
    $stdout.flush
    puts Util.warning(" - Health check did not fail within #{max_wait}s, proceeding anyway")
    false
end

def wait_for_lb_propagation(seconds=5)
    # Wait for LB to propagate the removal and for in-flight requests to complete
    puts " - Waiting #{seconds}s for LB propagation and in-flight requests..."
    sleep seconds
end

def wait_until_up(dn, iteration=0, max=25)
    dots = iteration % 3 + 1
    dot_display = "." * dots + " " * (3 - dots)
    print "\r - Waiting for node #{dn.node.uri} to become healthy #{dot_display}"
    $stdout.flush
    sleep 1
    dn.update_status

    if !dn.healthy? && iteration < max
        wait_until_up(dn, iteration + 1, max)
    elsif iteration > 0
        # Clear the waiting line when done
        print "\r" + " " * 80 + "\r"
        $stdout.flush
    end
end

def deployment_dir(file)
  File.basename(file).sub(/\.tar\.gz$/, "")
end

def create_deploy_script(config, file)
    name = File.join(TMP_DIR, "deploy.#{config.name}.sh")
    logfile = "#{config.name}.log"
    dir = deployment_dir(file)

    script = <<~EOS
    #!/bin/sh
    ./deploy/delete-old-deploys.rb --app #{config.name}
    rm -rf #{dir}
    tar --warning=no-unknown-keyword -xzf #{File.basename(file)}
    cp #{RUN_SCRIPT_NAME} #{dir}/
    touch #{logfile}
    mv -f #{logfile} #{logfile}.last
    ./deploy/kill.rb --app #{config.name}
    cd #{dir} && nohup ./#{RUN_SCRIPT_NAME} > ../#{logfile} 2>&1 &
    EOS

    File.open(name, "w") do |f|
        f << script
    end

    Util.run("chmod +x #{name}")

    name
end

def create_tarball(config, release_file, deploy_script, run_script, node_suffix)
    tarball = File.join(TMP_DIR, "deployment.#{config.name}.#{node_suffix}.tar.gz")

    # Copy files to TMP_DIR
    release_basename = File.basename(release_file)
    deploy_basename = File.basename(deploy_script)
    run_basename = File.basename(run_script)

    Util.run("cp #{release_file} #{TMP_DIR}/") if release_file != File.join(TMP_DIR, release_basename)

    # Build tarball with files from TMP_DIR
    tar_files = [release_basename, deploy_basename, run_basename].map { |f| "-C #{TMP_DIR} #{f}" }.join(" ")
    Util.run("xattr -cr lib deploy bin dist")
    Util.run("COPYFILE_DISABLE=1 tar --no-mac-metadata -czf #{tarball} lib deploy bin dist #{tar_files}")
    tarball
end

nodes = if args.node
            env.nodes.filter { |n| args.node == n.uri }
        else
            env.nodes
        end

if nodes.empty?
    if node.to_s.empty?
        Util.exit_with_error("No nodes configured for #{config.name}")
    else
        Util.exit_with_error("Node URI #{node} not found for #{config.name}")
    end
end
devops_token = vars["DEVOPS_TOKEN"]
if devops_token.nil? || devops_token.empty?
    Util.exit_with_error("DEVOPS_TOKEN environment variable is required")
end
deployment_nodes = nodes.each_with_index.map { |n, i| DeploymentNode.new(config, n, i, devops_token) }

deploy_script = create_deploy_script(config, file)

# Create per-node tarballs with node-specific run scripts
node_tarballs = {}
deployment_nodes.each do |dn|
    run_script = File.join(TMP_DIR, RUN_SCRIPT_NAME)
    RunScript.new(config, file, vars, env.nodes, dn.index).to_file(run_script)
    node_suffix = dn.node.job_server? ? "jobs" : "default"
    # Reuse tarball if same type already created
    if !node_tarballs[node_suffix]
        node_tarballs[node_suffix] = create_tarball(config, file, deploy_script, run_script, node_suffix)
    end
    dn.instance_variable_set(:@tarball, node_tarballs[node_suffix])
end

puts ""
puts Util.underline("Uploading tarballs to all nodes and checking node status")
threads = deployment_nodes.map do |dn|
  [
    Thread.new do
      if !SKIP_UPLOAD
        dn.upload_file(dn.instance_variable_get(:@tarball))
      end
    end,
    Thread.new do
        dn.update_status
    end
  ]
end.flatten
threads.each(&:join)

use_load_balancer = deployment_nodes.length > 1
if !use_load_balancer
    puts Util.warning("Single node deployment - skipping load balancer drain (brief downtime expected)")
end

deployment_nodes.sort_by { |dn| dn.healthy? ? (dn.job_server? ? 2 : 3) : 1 }.each do |dn|
    puts ""
    puts Util.underline("Starting deployment to node #{dn.node.uri}")
    tarball = dn.instance_variable_get(:@tarball)
    dn.execute("rm -rf lib deploy bin")
    dn.execute("tar --warning=no-unknown-keyword -xzf #{File.basename(tarball)}")
    if use_load_balancer
        puts "Starting drain on node #{dn.node.uri}"
        dn.start_drain
        wait_until_unhealthy(dn)
        puts "Removing node #{dn.node.uri} from load balancer"
        do_client.remove_droplet_by_ip_address(dn.node.uri)
        wait_for_lb_propagation()
    end
    dn.execute("./#{File.basename(deploy_script)}")
    wait_until_up(dn)
    if use_load_balancer
        puts "Adding node #{dn.node.uri} to load balancer"
        do_client.add_droplet_by_ip_address(dn.node.uri)
        wait_until_healthy_in_lb(do_client, dn)
    end
    puts "Done. Node status is #{dn.status.status}"
    if !dn.healthy?
        Util.exit_with_error("Aborting release as node failed to become healthy")
    end
end

healthy = deployment_nodes.filter { |dn| dn.healthy? }
not_healthy = deployment_nodes.filter { |dn| !dn.healthy? }

puts ""
if not_healthy.empty?
  job_servers = deployment_nodes.filter { |dn| dn.job_server? }
  if job_servers.length == 0
    puts Util.underline("No job servers")
    puts "Deployment is complete. There is no job server."

  elsif job_servers.length > 1
    puts Util.underline("Multiple job servers")
    puts "Deployment is complete. We expected a single job server but found multiple:"
    job_servers.each do |dn|
      puts " - #{dn.node.uri}"
    end

  else
    js = job_servers.first
    puts "Deployment successful. All nodes are healthy and there is exactly 1 job server [#{js.node.uri}]"
  end

elsif healthy.empty?
    puts Util.underline("SERVICE OUTAGE")
    puts "No nodes are healthy"

else
    puts Util.underline("The following nodes are not healthy")
    not_healthy.each do |n|
        puts " - %s" % n.node.uri
    end

end

puts ""
duration = (Time.now - start).to_i
puts "Deploy duration: #{duration} seconds"
puts ""
