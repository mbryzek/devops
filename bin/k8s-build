#!/usr/bin/env ruby

# k8s-build: Build and push Docker images to DigitalOcean Container Registry
#
# Usage:
#   k8s-build [--app APP] [--version VERSION] [--no-cache]
#
# Examples:
#   k8s-build                                    # Build current app (inferred from directory)
#   k8s-build --app platform                     # Build platform
#   k8s-build --app platform --version v1.2.3   # Build and push specific version
#
# Prerequisites:
#   - Docker installed and running
#   - doctl authenticated (for pushing to DOCR)

load File.join(File.dirname(__FILE__), '../lib/common.rb')

args = Args.parse(ARGV, ["app"])

# Registry configuration
REGISTRY = 'registry.digitalocean.com/bryzek'

source_dir = AppConfig.source_dir(args.app)

# Get version - ask for tag if not specified
version = args.version
unless version
  Dir.chdir(source_dir) do
    version = Tag.ask
    if version.empty?
      Util.exit_with_error("No tag available. Please specify --version")
    end
  end
end

# Verify source directory exists
unless File.directory?(source_dir)
  Util.exit_with_error("Source directory not found: #{source_dir}")
end

# Verify Dockerfile exists
dockerfile = File.join(source_dir, 'Dockerfile')
unless File.exist?(dockerfile)
  Util.exit_with_error("Dockerfile not found: #{dockerfile}\nPlease create a Dockerfile in #{source_dir}")
end

image_name = "#{REGISTRY}/#{args.app}"
image_tag = "#{image_name}:#{version}"
latest_tag = "#{image_name}:latest"

# Check if image already exists locally
image_exists = !`docker images -q #{image_tag}`.strip.empty?

should_build = true
if image_exists
  puts ""
  puts "Image already exists: #{image_tag}"
  puts ""
  choice = Ask.select_from_list("What would you like to do?", ["Rebuild image", "Push existing image"])
  should_build = (choice == "Rebuild image")

  if should_build
    # Delete existing image
    Util.run("docker rmi #{image_tag} #{latest_tag}", ignore_error: true)
  end
end

if should_build
  artifact = AppConfig.artifact(args.app)
  app_port = AppConfig.port(args.app)

  puts ""
  puts "=" * 60
  puts "Building Application"
  puts "=" * 60
  puts "  App:      #{args.app}"
  puts "  Artifact: #{artifact}"
  puts "  Version:  #{version}"
  puts "  Source:   #{source_dir}"
  puts "  Image:    #{image_tag}"
  puts "=" * 60
  puts ""

  # Step 1: Build locally with sbt
  puts "Step 1: Building with sbt..."
  Dir.chdir(source_dir) do
    Util.run("sbt #{artifact}/dist")
  end

  # Step 2: Extract distribution
  puts ""
  puts "Step 2: Extracting distribution..."
  dist_dir = File.join(source_dir, 'dist')
  FileUtils.rm_rf(dist_dir)
  FileUtils.mkdir_p(dist_dir)

  zip_file = Dir.glob("#{source_dir}/#{artifact}/target/universal/*.zip").first
  unless zip_file
    Util.exit_with_error("Distribution zip not found in #{artifact}/target/universal/")
  end

  Dir.chdir(dist_dir) do
    Util.run("unzip -q #{zip_file}")
    # Move contents up from nested directory
    nested_dir = Dir.glob("*").find { |d| File.directory?(d) }
    if nested_dir
      Util.run("mv #{nested_dir}/* . && rmdir #{nested_dir}")
    end
    # Remove Windows batch files
    FileUtils.rm_f(Dir.glob("bin/*.bat"))
  end

  # Step 3: Build Docker image
  puts ""
  puts "Step 3: Building Docker image..."
  Dir.chdir(source_dir) do
    cache_arg = args.no_cache ? '--no-cache' : ''
    Util.run("docker build --platform linux/amd64 #{cache_arg} --build-arg APP_PORT=#{app_port} --build-arg ARTIFACT=#{artifact} -t #{image_tag} .")
  end

  # Cleanup dist directory
  FileUtils.rm_rf(dist_dir)

  puts ""
  puts "Build successful!"
  puts "  Image: #{image_tag}"

  # Tag as latest after successful build
  Util.run("docker tag #{image_tag} #{latest_tag}")
  puts "  Tagged: #{latest_tag}"
end

# Always push to registry
puts ""
puts "=" * 60
puts "Pushing to registry"
puts "=" * 60

# Login to DOCR
Util.run("doctl registry login")

# Push both tags
Util.run("docker push #{image_tag}")
Util.run("docker push #{latest_tag}")

puts ""
puts "Push successful!"
puts "  #{image_tag}"
puts "  #{latest_tag}"

puts ""
puts "Version: #{version}"
