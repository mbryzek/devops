#!/usr/bin/env ruby

# k8s-secrets: Sync environment secrets from git-crypt to Kubernetes
#
# Usage:
#   k8s-secrets --app APP [--env ENV] [--apply]
#
# Examples:
#   k8s-secrets --app platform                    # Preview secrets (dry-run)
#   k8s-secrets --app platform --apply            # Apply secrets to cluster
#   k8s-secrets --app platform --env development  # Use development environment
#
# Prerequisites:
#   - kubectl configured with cluster access
#   - git-crypt unlocked in env/ repository

require 'optparse'
require 'json'
require 'base64'
require 'fileutils'
require 'yaml'

SCRIPT_DIR = File.dirname(__FILE__)
ENV_DIR = File.join(SCRIPT_DIR, '../../env')

# Kubernetes namespace
K8S_NAMESPACE = 'bryzek-production'

# Valid applications
VALID_APPS = %w[platform acumen]

options = {
  env: 'production',
  apply: false
}

OptionParser.new do |opts|
  opts.banner = "Usage: k8s-secrets --app APP [options]"

  opts.on("--app APP", "Application name (#{VALID_APPS.join(', ')})") do |app|
    options[:app] = app
  end

  opts.on("--env ENV", "Environment (production, development) [default: production]") do |env|
    options[:env] = env
  end

  opts.on("--apply", "Apply secrets to Kubernetes cluster") do
    options[:apply] = true
  end

  opts.on("--namespace NS", "Kubernetes namespace [default: #{K8S_NAMESPACE}]") do |ns|
    options[:namespace] = ns
  end

  opts.on("-h", "--help", "Show this help") do
    puts opts
    exit
  end
end.parse!

# Validate app
unless options[:app]
  puts "Error: --app is required"
  puts "Valid apps: #{VALID_APPS.join(', ')}"
  exit 1
end

unless VALID_APPS.include?(options[:app])
  puts "Error: Invalid app '#{options[:app]}'"
  puts "Valid apps: #{VALID_APPS.join(', ')}"
  exit 1
end

app = options[:app]
environment = options[:env]
namespace = options[:namespace] || K8S_NAMESPACE

def load_env_file(app, filename)
  env_path = File.join(ENV_DIR, "apps/#{app}/env/#{filename}.env")

  unless File.exist?(env_path)
    puts "Warning: Environment file not found: #{env_path}"
    return {}
  end

  # Check if file is encrypted (git-crypt)
  header = File.binread(env_path, 10) rescue nil
  if header&.start_with?("\x00GITCRYPT")
    puts "Environment file is encrypted. Please run 'git-crypt unlock' in #{ENV_DIR}"
    exit 1
  end

  data = {}
  File.readlines(env_path).each do |line|
    line = line.strip
    next if line.empty? || line.start_with?('#')

    key, value = line.split('=', 2)
    next if key.to_s.strip.empty?

    data[key.strip] = value.to_s.strip
  end
  data
end

# Load environment variables (environment-specific + common)
puts "Loading environment variables for #{app} (#{environment})..."
vars = {}
[environment, 'common'].each do |filename|
  file_vars = load_env_file(app, filename)
  file_vars.each do |k, v|
    if vars.key?(k)
      puts "Warning: Duplicate variable '#{k}' - using value from #{filename}"
    end
    vars[k] = v
  end
end

if vars.empty?
  puts "Error: No environment variables found"
  exit 1
end

puts "Found #{vars.size} environment variables"
puts ""

# Generate Kubernetes Secret manifest
secret_name = "#{app}-secrets"
config_name = "#{app}-config"

# Separate sensitive vs non-sensitive config
# Convention: Variables starting with CONF_ are config, others are secrets
config_vars = vars.select { |k, _| k.start_with?('CONF_') }
secret_vars = vars.reject { |k, _| k.start_with?('CONF_') }

# Also add database credentials secret if database config exists
db_vars = {}
%w[DB_HOST DB_PORT DB_NAME DB_USER DB_PASSWORD DATABASE_URL].each do |key|
  db_vars[key] = vars[key] if vars[key]
end

# Generate Secret YAML
secret_manifest = {
  'apiVersion' => 'v1',
  'kind' => 'Secret',
  'metadata' => {
    'name' => secret_name,
    'namespace' => namespace,
    'labels' => {
      'app' => app,
      'app.kubernetes.io/name' => app
    }
  },
  'type' => 'Opaque',
  'stringData' => secret_vars
}

# Generate ConfigMap YAML
configmap_manifest = {
  'apiVersion' => 'v1',
  'kind' => 'ConfigMap',
  'metadata' => {
    'name' => config_name,
    'namespace' => namespace,
    'labels' => {
      'app' => app,
      'app.kubernetes.io/name' => app
    }
  },
  'data' => config_vars
}

# Generate DB credentials Secret if we have database vars
db_secret_manifest = nil
unless db_vars.empty?
  db_secret_manifest = {
    'apiVersion' => 'v1',
    'kind' => 'Secret',
    'metadata' => {
      'name' => "#{app}-db-credentials",
      'namespace' => namespace,
      'labels' => {
        'app' => app,
        'app.kubernetes.io/name' => app
      }
    },
    'type' => 'Opaque',
    'stringData' => db_vars
  }
end

# Output summary
puts "=" * 60
puts "Kubernetes Secrets Summary"
puts "=" * 60
puts "  Namespace:    #{namespace}"
puts "  Secret:       #{secret_name} (#{secret_vars.size} vars)"
puts "  ConfigMap:    #{config_name} (#{config_vars.size} vars)"
puts "  DB Secret:    #{app}-db-credentials (#{db_vars.size} vars)" if db_secret_manifest
puts "=" * 60
puts ""

# Show variable names (not values!)
puts "Secret variables (#{secret_name}):"
secret_vars.keys.sort.each { |k| puts "  - #{k}" }
puts ""

puts "ConfigMap variables (#{config_name}):"
config_vars.keys.sort.each { |k| puts "  - #{k}" }
puts ""

if db_secret_manifest
  puts "DB Credentials (#{app}-db-credentials):"
  db_vars.keys.sort.each { |k| puts "  - #{k}" }
  puts ""
end

if options[:apply]
  puts "Applying to Kubernetes cluster..."

  # Write manifests to temp files
  tmp_dir = "/tmp/k8s-secrets-#{app}"
  FileUtils.mkdir_p(tmp_dir)

  secret_file = File.join(tmp_dir, "secret.yaml")
  configmap_file = File.join(tmp_dir, "configmap.yaml")

  File.write(secret_file, secret_manifest.to_yaml)
  File.write(configmap_file, configmap_manifest.to_yaml)

  # Apply Secret
  puts "  Applying #{secret_name}..."
  system("kubectl apply -f #{secret_file}")
  exit 1 unless $?.success?

  # Apply ConfigMap
  puts "  Applying #{config_name}..."
  system("kubectl apply -f #{configmap_file}")
  exit 1 unless $?.success?

  # Apply DB credentials if present
  if db_secret_manifest
    db_file = File.join(tmp_dir, "db-secret.yaml")
    File.write(db_file, db_secret_manifest.to_yaml)
    puts "  Applying #{app}-db-credentials..."
    system("kubectl apply -f #{db_file}")
    exit 1 unless $?.success?
  end

  # Clean up
  FileUtils.rm_rf(tmp_dir)

  puts ""
  puts "Secrets applied successfully!"
else
  puts "DRY RUN - Use --apply to apply secrets to cluster"
  puts ""
  puts "Preview (Secret):"
  puts secret_manifest.to_yaml
end
